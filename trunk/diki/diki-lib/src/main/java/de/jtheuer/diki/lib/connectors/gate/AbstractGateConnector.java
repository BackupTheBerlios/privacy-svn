/**
 *     This file is part of Diki.
 *
 *     Copyright (C) 2009 jtheuer
 *     Please refer to the documentation for a complete list of contributors
 *
 *     Diki is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     Diki is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with Diki.  If not, see <http://www.gnu.org/licenses/>.
 */
package de.jtheuer.diki.lib.connectors.gate;

import java.awt.Image;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.paceproject.diki.elmo.Query;

import de.jtheuer.diki.lib.NetworkConnection;
import de.jtheuer.diki.lib.connectors.*;
import de.jtheuer.diki.lib.connectors.xmpp.XMPPConnector;
import de.jtheuer.diki.lib.query.NetworkQuery;
import de.jtheuer.diki.lib.query.QueryException;
import de.jtheuer.sesame.QNameURI;

/**
 * @author Jan Torben Heuer <jan.heuer@uni-muenster.de>
 * 
 * An {@link AbstractSimpleConnector} can handle incomming and outgoing queries.
 * The most important concrete implementation ist the {@link XMPPConnector}.
 * 
 * This class was seperated from the {@link XMPPConnector} due to JUnit
 * refactoring needs.
 * 
 */
public abstract class AbstractGateConnector<T> extends AbstractConnector implements GateConnector<T> {

	/* auto generated Logger */@SuppressWarnings("unused")
	private final static Logger LOGGER = Logger.getLogger(AbstractGateConnector.class.getName());

	protected final Set<QNameURI> querySet = Collections.synchronizedSet(new HashSet<QNameURI>());

	private int TIMEOUT = 60*60; /* one hour... */

	/**
	 * @param connection
	 */
	public AbstractGateConnector(NetworkConnection connection) {
		super(connection);
	}
	
	/**
	 * @param connection
	 */
	public AbstractGateConnector(NetworkConnection connection, int timeout) {
		super(connection);
		this.TIMEOUT = timeout;
	}

	/**
	 * @param name
	 * @param icon
	 * @param connection
	 */
	public AbstractGateConnector(String name, Image icon, NetworkConnection connection) {
		super(name, icon, connection);
	}

	@Override
	public void evaluate(NetworkQuery query) {
		/* mark own query so that we don not answer it later, again! */
		querySet.add(query.getQueryID());
		
		/* iterate over friends and send the query to them */
		List<T> friends = getFriends();
		for (T friend : friends) {
			/* if not blacklisted (the original query-sender is always blacklisted */
			QNameURI uri = toURI(friend);
			if(query.isRecipient(uri)) {
				query.getExecutor().execute(forwardQueryTo(uri, query));				
			}
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.gate.GateConnector#forwardQueryTo(java.lang.String,
	 *      de.jtheuer.diki.lib.query.Query)
	 */
	@Override
	public Runnable forwardQueryTo(final QNameURI to, final NetworkQuery query) {

		return new Runnable() {
			@Override
			public void run() {
				
				try {
					NetworkQuery childQuery = query.createChildQuery();
					
					/* create a result collector for this query */
					Conversation tracker = getConversation(to, childQuery);

					
					Query elmoQuery = childQuery.getElmoQuery();
					/* reduce distance by 1 */
					elmoQuery.setDistance(elmoQuery.getDistance()-1);

					tracker.sendQuery();
					tracker.blockUntilFinisched(TIMEOUT);
				} catch (GateCommunicationException e) {
					LOGGER.log(Level.SEVERE,"autogenerated catch-block", e);
				} catch (InterruptedException e) {
					LOGGER.log(Level.SEVERE,"autogenerated catch-block", e);
				} catch (QueryException e) {
					LOGGER.log(Level.WARNING,"cannot send message to " + to.toString(), e);
				}
			}
			
			@Override
			public String toString() {
				return "GateConnector [" + to + "]";
			}
		};
	}

	protected abstract Conversation getConversation(QNameURI to, NetworkQuery query);


	
	/**
	 * converts from the genric T datatype to a valid uri representing the friend.
	 * @param friend
	 * @return
	 */
	protected QNameURI toURI(T friend) {
		return new QNameURI(friend.toString());
	}

	@Override
	public void addFriend(QNameURI friend) throws ConnectorException {}

	@Override
	public List<T> getFriends() {
		return null;
	}

	@Override
	public List<QNameURI> getFriendsURIs() {
		return null;
	}

	@Override
	public String getUserNamespace() {
		return null;
	}

	@Override
	public boolean isOnline(QNameURI username) {return true;}
	
}