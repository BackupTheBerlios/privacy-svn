/**
 *     This file is part of Diki.
 *
 *     Copyright (C) 2009 jtheuer
 *     Please refer to the documentation for a complete list of contributors
 *
 *     Diki is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     Diki is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with Diki.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 (c) by Jan Torben Heuer <jan.heuer@uni-muenster.de

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/
 */
package de.jtheuer.diki.lib.connectors.xmpp;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.jivesoftware.smack.*;
import org.jivesoftware.smack.filter.PacketFilter;
import org.jivesoftware.smack.packet.*;

import de.jtheuer.diki.lib.NetworkConnection;
import de.jtheuer.diki.lib.connectors.ConnectorException;
import de.jtheuer.diki.lib.connectors.ParameterProperties;
import de.jtheuer.diki.lib.connectors.ParameterProperties.Field;
import de.jtheuer.diki.lib.connectors.ParameterProperties.TYPE;
import de.jtheuer.diki.lib.connectors.gate.AbstractGateConnector;
import de.jtheuer.diki.lib.connectors.gate.Conversation;
import de.jtheuer.diki.lib.query.NetworkQuery;
import de.jtheuer.sesame.QNameURI;

/**
 * Concrete implementation for XMPP Networks
 */
public class XMPPConnector extends AbstractGateConnector<String> implements MessageListener {
	/* autogenerated Logger */@SuppressWarnings("unused")
	private final static Logger LOGGER = Logger.getLogger(XMPPConnector.class.getName());

	/* configuration file parameters */
	public static final String KEY_USER = "xmpp.username";
	public static final String KEY_PASSWORD = "xmpp.password";
	public static final String KEY_HOST = "xmpp.host";
	public static final String KEY_TIMEOUT = "network timeout";
	public static final String NAME = "xmpp network";

	private static final String FRIENDS = "DIKI_FRIENDS";
	private static final String[] FRIENDSGROUP = new String[] { FRIENDS };

	private String username;
	private String password;
	private String host;

	protected ConcurrentHashMap<String, XMPPChat> chatlist = new ConcurrentHashMap<String, XMPPChat>();
	XMPPConnection xmppconnection;

	public XMPPConnector(NetworkConnection connection) {
		super(NAME, null, connection);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.Connector#connect()
	 */
	@Override
	public void connect(Properties prop) throws ConnectorException {
		setStatus(Status.Connecting);
		username = prop.getProperty(KEY_USER);
		password = prop.getProperty(KEY_PASSWORD);
		host = prop.getProperty(KEY_HOST);

		LOGGER.info("Connecting to " + host);
		/* try connect */
		try {
			/* allow reconnect */
			if (xmppconnection != null) {
				xmppconnection.disconnect();
			}
			ConnectionConfiguration c;
			xmppconnection = new XMPPConnection(host);
			xmppconnection.connect();
			xmppconnection.addConnectionListener(new XMPPConnectionListener(getConnection(), this));
		} catch (Exception e) {
			setStatus(Status.Disconnected);
			throw new ConnectorException(e);
		}

		LOGGER.info("Log in user: " + username);
		/* try login */
		try {
			xmppconnection.login(username, password);
		} catch (XMPPException e) {
			/* invalid password or invalid user? Try to create new Account */
			try {
				xmppconnection.getAccountManager().createAccount(username, password);

				xmppconnection.disconnect();
				xmppconnection.connect();
				
				xmppconnection.login(username, password);
			} catch (XMPPException e1) {
				setStatus(Status.Disconnected);
				throw new ConnectorException("Can neither login nor register the user: " + username);
			}
		}
		/* successful. Create listener for incoming messages */

		xmppconnection.getRoster().addRosterListener(new XMPPRosterListener(getConnection().getUserFactory(),this));
		
		PacketFilter filter = new PacketFilter() {
			public boolean accept(Packet packet) {
				if (!(packet instanceof Message)) {
					return false;
				}
				Message.Type messageType = ((Message) packet).getType();
				return messageType != Message.Type.groupchat && messageType != Message.Type.headline;
			}
		};

		xmppconnection.addPacketListener(new PacketListener() {

			public void processPacket(Packet packet) {
				Message message = (Message) packet;
				XMPPChat chat;
				if (message.getThread() == null) {
					/* no thread? discard */
					LOGGER.info("Discarding message from " + message.getFrom() + " because it has no threadid");
				} else {
					chat = getThreadChat(message.getThread(), packet.getFrom());

					if(chat != null) {
						chat.processMessage(message);
					} else {
						LOGGER.info("Discarding message from " + message.getFrom() + " because Chat for thread " + message.getThread() + " already closed. Content was:" + message.getBody());
					}
				}
			}
		}, filter);

		/* create default friend group */
		if (xmppconnection.getRoster().getGroup(FRIENDS) == null) {
			xmppconnection.getRoster().createGroup(FRIENDS);
		}

		LOGGER.info("successful");
		setStatus(Status.Connected);
	}

	private XMPPChat getThreadChat(String thread, String to) {
		XMPPChat chat = chatlist.get(thread);

		if (chat == null) {
			chat = new XMPPChat(this, thread, to, null);
			chatlist.put(thread, chat);
			new XMPPQueryResult(this, chat, getConnection(), querySet);
		} else if (chat instanceof XMPPChat.ClosedChat) {
			return null;
		}

		return chat;
	}

	@Override
	public void disconnect() {
		super.disconnect();
		xmppconnection.disconnect();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.Connector#getParameters()
	 */
	@Override
	public Properties getParameters() {
		return null;
	}
	
	@Override
	public ParameterProperties getProperties() {
		ParameterProperties p = super.getProperties();
		p.addField(new Field(KEY_USER,"username",true));
		p.addField(new Field(KEY_PASSWORD,"password",true,TYPE.PASSWORD));
		p.addField(new Field(KEY_HOST,"hostname",true,"v-tml.uni-muenster.de","geofs.uni-muenster.de","jabber.ccc.de","jabber.org","swissjabber.ch"));
		return p;
	}

	/**
	 * @return user@hostname/ or null if not connected
	 */
	@Override
	public String getUserNamespace() {
		if(xmppconnection == null || username == null || host == null) {
			throw new IllegalStateException("Not proper initialized");
		}
		return "xmpp:" + username + "@" + host + "/";
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.gate.GateConnector#getFriends()
	 */
	@Override
	public List<String> getFriends() {
		RosterGroup group = xmppconnection.getRoster().getGroup(FRIENDS);
		if(group != null) {
			Collection<RosterEntry> entries = group.getEntries();
			List<String> friends = new ArrayList<String>(entries.size());

			for (RosterEntry friend : entries) {
				if(isOnline(friend.getUser())) {
					friends.add(friend.getUser());
				}
			}
			return friends;
		} else {
			return Collections.emptyList();
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.gate.GateConnector#getFriendsURIs()
	 */
	@Override
	public List<QNameURI> getFriendsURIs() {
		Collection<RosterEntry> entries = xmppconnection.getRoster().getGroup(FRIENDS).getEntries();

		List<QNameURI> friends = new ArrayList<QNameURI>(entries.size());

		for (RosterEntry friend : entries) {
			String to = friend.getUser();
			friends.add(toURI(to));
		}
		return friends;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.gate.AbstractGateConnector#getConversation(java.lang.String,
	 *      de.jtheuer.diki.lib.query.Query, de.jtheuer.diki.lib.util.QNameURI)
	 */
	@Override
	protected Conversation getConversation(QNameURI to, NetworkQuery query) {
		XMPPChat chat = new XMPPChat(this, query.getSesameContext().getQName().toString(), uriToString(to), null);
		chatlist.put(query.getSesameContext().getQName().toString(), chat);
		return new XMPPConversation(query, chat, to);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.jivesoftware.smack.MessageListener#processMessage(org.jivesoftware.smack.Chat,
	 *      org.jivesoftware.smack.packet.Message)
	 */
	@Override
	public void processMessage(Chat arg0, Message arg1) {
		LOGGER.finest(arg1.toXML());
	}

	/**
	 * @param xm
	 */
	public void sendPacket(Message xm) {
		xmppconnection.sendPacket(xm);
	}

	/**
	 * The xmpp userid of the local user
	 * 
	 * @return
	 */
	public String getUser() {
		return xmppconnection.getUser();
	}

	/**
	 * closes a chat and removes all referenes to it
	 * 
	 * @param chat
	 */
	public void closeChat(XMPPChat chat) {
		chatlist.put(chat.getThreadid(), XMPPChat.CLOSED);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.gate.GateConnector#addFriend(java.lang.Object)
	 */
	@Override
	public void addFriend(QNameURI friend) throws ConnectorException {
		String xmppuri = uriToString(friend);
		
		try {
			xmppconnection.getRoster().createEntry(xmppuri, xmppuri, FRIENDSGROUP);
		} catch (NullPointerException e) {
			LOGGER.log(Level.SEVERE, "Expected group " + FRIENDS + " to be existing!", e);
		} catch (XMPPException e) {
			throw new ConnectorException(e);
		}
	}

	/**
	 * @param friend
	 * @return
	 */
	private String uriToString(QNameURI friend) {
		String xmppuri = friend.toString();

		/* strip xmpp: head */
		if (xmppuri.startsWith("xmpp:")) {
			xmppuri = xmppuri.substring(5);
		}

		/* remove trailing / */
		if (xmppuri.endsWith("/")) {
			xmppuri = xmppuri.substring(0, xmppuri.length() - 1);
		}

		return xmppuri;
	}
	
	@Override
	public QNameURI toURI(String friend) {
		return new QNameURI("xmpp:" + friend + "/");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.jtheuer.diki.lib.connectors.gate.GateConnector#deleteFriend(de.jtheuer.diki.lib.util.QNameURI)
	 */
	@Override
	public void deleteFriend(QNameURI friend) throws ConnectorException {
		String xmppuri =  uriToString(friend);


		RosterEntry entry = xmppconnection.getRoster().getEntry(xmppuri);
		try {
			xmppconnection.getRoster().removeEntry(entry);
		} catch (XMPPException e) {
			throw new ConnectorException(e);
		}
	}

	@Override
	public boolean isOnline(QNameURI username) {
		String xmppuri =  uriToString(username);
		return isOnline(xmppuri);
	}

	private boolean isOnline(String username) {
		Presence friend_presence = xmppconnection.getRoster().getPresence(username);
		if (friend_presence != null) {
			if (friend_presence.isAvailable()) {
				return true;
			}
		}
		return false;
	}	
}
