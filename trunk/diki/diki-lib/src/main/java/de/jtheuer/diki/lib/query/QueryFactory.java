/**
 *     This file is part of Diki.
 *
 *     Copyright (C) 2009 jtheuer
 *     Please refer to the documentation for a complete list of contributors
 *
 *     Diki is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     Diki is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with Diki.  If not, see <http://www.gnu.org/licenses/>.
 */
package de.jtheuer.diki.lib.query;

import java.util.concurrent.ExecutorService;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.openrdf.repository.RepositoryException;
import org.paceproject.diki.elmo.Query;

import de.jtheuer.diki.lib.NetworkConnection;
import de.jtheuer.diki.lib.connectors.Connector;
import de.jtheuer.diki.lib.connectors.Connector.Status;
import de.jtheuer.sesame.*;

/**
 * @author Jan Torben Heuer <jan.heuer@uni-muenster.de> responsible for routing
 *         Queries between the components.
 * 
 * Transforms {@link Query} instances into a {@link NetworkQuery} instances. You
 * can reuse this Factory, so normally one instance should be enough.
 * 
 * Queries are then forwarded to the Connectors of the {@link NetworkConnection}.
 */
public class QueryFactory {
	/* automatically generated Logger */@SuppressWarnings("unused")
	private static final Logger LOGGER = Logger.getLogger(QueryFactory.class.getName());
	private ExecutorService executors_cache;
	private NetworkConnection connection;
	private final static int DEFAULTDISTANCE = 5;
	private SesameContextFactory factory;

	/**
	 * @param networkConnection
	 */
	public QueryFactory(NetworkConnection networkConnection, ExecutorService executors) {
		this.connection = networkConnection;
		executors_cache = executors;
	}

	/**
	 * Sends the supplied query to all (online) {@link Connector}s of the
	 * {@link NetworkConnection}
	 * 
	 * @param query
	 * @param result
	 */
	public Query forwardQueries(final QueryInterface query, final QueryResultListener<Object> result) {
		/*
		 * create new QueryExecutor that keeps track of solved and unsolved
		 * queries
		 */

		try {
			final AbstractNetworkQuery<?> nc = new ConceptNetworkQuery(query, result, connection, DEFAULTDISTANCE);
			final QueryExecutor executor = new QueryExecutor(executors_cache, result);
			executor.execute(new Runnable() {
				public void run() {

					nc.setExecutor(executor);
					recursiveConnectorsquery(nc);

				}
			});

			return nc.getElmoQuery();
		} catch (QueryException e) {
			LOGGER.log(Level.SEVERE, "autogenerated catch-block", e);
		} catch (RepositoryException e) {
			LOGGER.log(Level.SEVERE, "autogenerated catch-block", e);
		}

		return null;
	}

	/**
	 * Sends the supplied query to all (online) {@link Connector}s of the
	 * {@link NetworkConnection}
	 * 
	 * @param query
	 * @param result
	 */
	public void forwardQueries(final AbstractNetworkQuery<?> query) {
		/*
		 * create new QueryExecutor that keeps track of solved and unsolved
		 * queries
		 */
		final QueryExecutor executor = new QueryExecutor(executors_cache, query.getResultListener());
		query.setExecutor(executor);
		executor.execute(new Runnable() {
			public void run() {
				recursiveConnectorsquery(query);
			}
		});
	}

	/**
	 * forwards the query to all connectors
	 * 
	 * @param networkQuery
	 */
	protected void recursiveConnectorsquery(final AbstractNetworkQuery<?> networkQuery) {

		/* ask all Connectors for a problem solver */
		for (final Connector c : connection.getConnectors()) {
			if (c.getStatus() == Status.Connected) {
				networkQuery.getExecutor().execute(new Runnable() {

					@Override
					public void run() {

						try {
							/*
							 * create a child query, remove initial distance and
							 * forward to connector
							 */
							NetworkQuery child = networkQuery.createChildQuery();

							Query q = child.getElmoQuery();
							double distance = q.getDistance();

							q.setDistance(distance - c.distance());
							if (q.getDistance() > 0) {
								LOGGER.fine("starting connector: " + c.getName());
								c.evaluate(child);
							} else {
								LOGGER.fine("skipping connector: " + c.getName() + " because distance is " + q.getDistance());
							}
						} catch (QueryException e) {
							LOGGER.log(Level.SEVERE, "error creating child query", e);
						}

					}

				});
			}
		}
	}

	public SesameContextWrapper createQueryContext() throws RepositoryException {
		if (factory == null) {
			/* xmpp:user@host/query/timemillis as string */
			QNameURI uri = new QNameURI(connection.getNamespaceFactory().getNamespace() + "query/" + Long.toString(System.currentTimeMillis(), 15));
			factory = connection.getSesame().createSesameFactory(uri);
		}
		return factory.createWrapper();
	}

}
